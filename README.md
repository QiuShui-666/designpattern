## 一、背景

Java设计模式是面向对象编程中的一种最佳实践，它们是从大量的软件开发实践中提炼出的、解决特定问题的通用解决方案。这些模式不仅适用于Java编程语言，也广泛应用于其他面向对象编程语言中。本README旨在介绍Java设计模式的基本概念、重要原则以及在JDK 17环境中如何有效地运用它们。

## 二、设计模式分类

设计模式按照其目标和作用通常分为三大类：

### 1. **创建型模式**（Creational Patterns）

关注对象的创建过程，旨在提供一种优雅的方式来创建对象，隐藏创建细节，使代码更具可重用性和灵活性。常见的创建型模式包括：

- **单例模式**（Singleton）：确保一个类仅有一个实例，并提供全局访问点。
- **工厂方法模式**（Factory Method）：定义一个用于创建对象的接口，但由子类决定实例化哪一个类。
- **抽象工厂模式**（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，无需指定具体类。
- **建造者模式**（Builder）：将复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。
- **原型模式**（Prototype）：通过复制现有实例来创建新实例，实现对象的克隆。

### 2. **结构型模式**（Structural Patterns）

关注类和对象的组合，通过定义对象间的关系（包括继承、组合等）来实现更加灵活的结构。常见的结构型模式包括：

- **适配器模式**（Adapter）：将一个类的接口转换成客户期望的另一个接口，使得原本不兼容的类可以一起工作。
- **装饰器模式**（Decorator）：动态地给对象添加新功能，同时保持类的结构不变。
- **代理模式**（Proxy）：为其他对象提供一个代理或占位符，以控制对这个对象的访问。
- **桥接模式**（Bridge）：将抽象部分与实现部分分离，使它们可以独立变化。
- **组合模式**（Composite）：将对象组合成树形结构，以表现“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
- **享元模式**（Flyweight）：通过共享大量细粒度对象来支持大量对象的复用，节省内存。

### 3. **行为型模式**（Behavioral Patterns）

关注对象间的职责分配、算法封装与通信机制，旨在改善程序在运行时的行为。常见的行为型模式包括：

- **策略模式**（Strategy）：定义了一系列算法，并将每个算法封装起来，使它们可以互相替换。策略模式让算法的变化独立于使用算法的客户。
- **模板方法模式**（Template Method）：在一个抽象类中定义一个操作的骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变结构的情况下重定义算法的某些步骤。
- **观察者模式**（Observer）：定义了对象间的一对多依赖关系，当一个对象的状态改变时，所有依赖于它的对象都会得到通知并自动更新。
- **迭代器模式**（Iterator）：提供一种顺序访问聚合对象元素的方法，而不暴露其内部表示。
- **责任链模式**（Chain of Responsibility）：通过使多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合。
- **命令模式**（Command）：将请求封装为一个对象，使得使用不同的请求、队列请求或支持撤销操作变得容易。
- **中介者模式**（Mediator）：定义一个中介对象来封装一系列对象之间的交互，降低对象之间的耦合。
- **访问者模式**（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。

## 三、设计原则

在实现设计模式时，应遵循以下核心设计原则：

- **单一职责原则**（SRP）：一个类或模块应有且仅有一个引起它变化的原因。
- **开闭原则**（OCP）：软件实体应当对扩展开放，对修改关闭。
- **里氏替换原则**（LSP）：子类型必须能够替换掉它们的基类型。
- **依赖倒置原则**（DIP）：高层次的模块不应该依赖于低层次的模块，二者都应该依赖于抽象。
- **接口隔离原则**（ISP）：客户端不应该被迫依赖于它不需要的接口方法。
- **迪米特法则**（LoD）/最少知识原则（LKP）：一个对象应当对其他对象有尽可能少的了解。
- **合成复用原则**（CRP）：优先使用对象组合而非类继承来达到复用的目的。

遵循这些原则有助于设计出高内聚、低耦合、易于扩展和维护的软件系统。
